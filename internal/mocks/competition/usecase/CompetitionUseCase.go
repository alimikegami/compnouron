// Code generated by mockery v2.12.2. DO NOT EDIT.

package mocks

import (
	dto "github.com/alimikegami/compnouron/internal/competition/dto"
	mock "github.com/stretchr/testify/mock"

	testing "testing"
)

// CompetitionUseCase is an autogenerated mock type for the CompetitionUseCase type
type CompetitionUseCase struct {
	mock.Mock
}

// AcceptCompetitionRegistration provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) AcceptCompetitionRegistration(id uint, userID uint) error {
	ret := _m.Called(id, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(id, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloseCompetitionRegistrationPeriod provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) CloseCompetitionRegistrationPeriod(id uint, userID uint) error {
	ret := _m.Called(id, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(id, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCompetition provides a mock function with given fields: competition, userID
func (_m *CompetitionUseCase) CreateCompetition(competition dto.CompetitionRequest, userID uint) error {
	ret := _m.Called(competition, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.CompetitionRequest, uint) error); ok {
		r0 = rf(competition, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteCompetition provides a mock function with given fields: competitionID, userID
func (_m *CompetitionUseCase) DeleteCompetition(competitionID uint, userID uint) error {
	ret := _m.Called(competitionID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(competitionID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAcceptedCompetitionParticipants provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) GetAcceptedCompetitionParticipants(id uint, userID uint) (interface{}, error) {
	ret := _m.Called(id, userID)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(uint, uint) interface{}); ok {
		r0 = rf(id, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint, uint) error); ok {
		r1 = rf(id, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompetitionByID provides a mock function with given fields: competitionID
func (_m *CompetitionUseCase) GetCompetitionByID(competitionID uint) (dto.DetailedCompetitionResponse, error) {
	ret := _m.Called(competitionID)

	var r0 dto.DetailedCompetitionResponse
	if rf, ok := ret.Get(0).(func(uint) dto.DetailedCompetitionResponse); ok {
		r0 = rf(competitionID)
	} else {
		r0 = ret.Get(0).(dto.DetailedCompetitionResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(competitionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompetitionRegistration provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) GetCompetitionRegistration(id uint, userID uint) (interface{}, error) {
	ret := _m.Called(id, userID)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(uint, uint) interface{}); ok {
		r0 = rf(id, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint, uint) error); ok {
		r1 = rf(id, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompetitions provides a mock function with given fields: limit, offset
func (_m *CompetitionUseCase) GetCompetitions(limit int, offset int) ([]dto.CompetitionResponse, error) {
	ret := _m.Called(limit, offset)

	var r0 []dto.CompetitionResponse
	if rf, ok := ret.Get(0).(func(int, int) []dto.CompetitionResponse); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.CompetitionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenCompetitionRegistrationPeriod provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) OpenCompetitionRegistrationPeriod(id uint, userID uint) error {
	ret := _m.Called(id, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(id, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Register provides a mock function with given fields: competitionRegistration, userID
func (_m *CompetitionUseCase) Register(competitionRegistration dto.CompetitionRegistrationRequest, userID uint) error {
	ret := _m.Called(competitionRegistration, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.CompetitionRegistrationRequest, uint) error); ok {
		r0 = rf(competitionRegistration, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RejectCompetitionRegistration provides a mock function with given fields: id, userID
func (_m *CompetitionUseCase) RejectCompetitionRegistration(id uint, userID uint) error {
	ret := _m.Called(id, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(id, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SearchCompetition provides a mock function with given fields: limit, offset, keyword
func (_m *CompetitionUseCase) SearchCompetition(limit int, offset int, keyword string) ([]dto.CompetitionResponse, error) {
	ret := _m.Called(limit, offset, keyword)

	var r0 []dto.CompetitionResponse
	if rf, ok := ret.Get(0).(func(int, int, string) []dto.CompetitionResponse); ok {
		r0 = rf(limit, offset, keyword)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.CompetitionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int, string) error); ok {
		r1 = rf(limit, offset, keyword)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCompetition provides a mock function with given fields: competition, id, userID
func (_m *CompetitionUseCase) UpdateCompetition(competition dto.CompetitionRequest, id uint, userID uint) error {
	ret := _m.Called(competition, id, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.CompetitionRequest, uint, uint) error); ok {
		r0 = rf(competition, id, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewCompetitionUseCase creates a new instance of CompetitionUseCase. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewCompetitionUseCase(t testing.TB) *CompetitionUseCase {
	mock := &CompetitionUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
